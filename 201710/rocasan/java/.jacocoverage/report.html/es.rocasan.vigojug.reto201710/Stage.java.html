<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="gl"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Stage.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCoverage analysis of project &quot;vigoreto-201710&quot; (powered by JaCoCo from EclEmma)</a> &gt; <a href="index.source.html" class="el_package">es.rocasan.vigojug.reto201710</a> &gt; <span class="el_source">Stage.java</span></div><h1>Stage.java</h1><pre class="source lang-java linenums">/*
 *
 * Copyright 2017 @ Santiago Rodríguez .
 *
 * License: MIT
 *
 * Project: vigoreto-201710
 *
 */
package es.rocasan.vigojug.reto201710;

import java.util.Collections;
import java.util.HashMap;

<span class="fc" id="L15">class MaxTicksReachException extends Exception {</span>
	
}

/**
 * Represents the number of attempts to explore a new possible state. It takes 
 * care of throw the MaxTicksReachException when number of ticks reach the limit.
 * @author Santiago Rodríguez 
 */
class Ticks {
	
	/**
	 * Limit of ticks before throw the exception.
	 */
	private Integer limit;
	
	/**
	 * Store the number of ticks made
	 */
	private Integer count;
	
<span class="fc" id="L36">	public Ticks(Integer limit) {</span>
<span class="fc" id="L37">		this.limit = limit;</span>
<span class="fc" id="L38">		this.count = 0;</span>
<span class="fc" id="L39">	}</span>
	
	/**
	 * Write down a tick and return the number of remaining ticks. If requested
	 * tick is over the limit, thow a MaxTicksReachException.
	 * @return
	 * @throws MaxTicksReachException 
	 */
	public Integer tick() throws MaxTicksReachException {
<span class="fc" id="L48">		count ++;</span>
<span class="fc bfc" id="L49" title="All 2 branches covered.">		if(count &gt; limit) {</span>
<span class="fc" id="L50">			throw new MaxTicksReachException();</span>
		}
<span class="fc" id="L52">		return limit - count;</span>
	}
}

/**
 * Simple class to hold a state information to find out a solution.
 * @author Santiago Rodríguez 
 */
class State {
	public String name;
	public String operation;
	public String fromState;
	public Integer recursionLevel;
<span class="fc" id="L65">	public State(String name, String operation, String fromState, Integer recursionLevel) {</span>
<span class="fc" id="L66">		this.name = name;</span>
<span class="fc" id="L67">		this.operation = operation;</span>
<span class="fc" id="L68">		this.fromState = fromState;</span>
<span class="fc" id="L69">		this.recursionLevel = recursionLevel;</span>
<span class="fc" id="L70">	}</span>
}


/**
 * Holds the jugs and target, and can init a research for a solution
 * @author Santiago Rodríguez 
 */
public class Stage {
	
	private static final int FILL = 0;
	private static final int EMPTY = 1;
	private static final int DUMP = 2;
	
	/**
	 * Quantity of units to be defined as target. Almost one jug must have that 
	 * or greater capacity
	 */
	private Integer target;
	
	/**
	 * List of jugs.
	 */
	private Jug[] jugs;
	
	/**
	 * State while solve. The key String is the comma separated amount of jugs, 
	 * that represents the state. The value is a array with the previous state,
	 * the instruction to reach the key state and the iteration.
	 */
<span class="fc" id="L100">	private HashMap&lt;String,State&gt; states = new HashMap();</span>
	
	/**
	 * Max number of instructions after declare the solve as unresolved.
	 */
	private Ticks maxTicks;
	
	/**
	 * Indicates the recursion level while solving.
	 */
	private Integer recursionLevel;
	
	/**
	 * Store the state key in states table tha represent the best solution found.
	 */
<span class="fc" id="L115">	private String bestStateSolution = null;</span>
	
	/**
	 * Indicates if the debug info is printed to the CLI.
	 */
<span class="fc" id="L120">	public Boolean debug = false;</span>
	
	/**
	 * Constructor that receibes the target to reach, and the list of jugs. The 
	 * default limit of ticks are 1000.
	 * @param target The amount that a jug should achieve to declare the stage solved
	 * @param jugs A array of Jugs
	 */
<span class="fc" id="L128">	public Stage(Integer target, Jug[] jugs) {</span>
<span class="fc" id="L129">		this.target = target;</span>
<span class="fc" id="L130">		this.jugs = jugs;</span>
<span class="fc" id="L131">		ensureTargetAndJugCapacities();</span>
<span class="fc" id="L132">		this.maxTicks = new Ticks(1000);</span>
<span class="fc" id="L133">	}</span>
	
	/**
	 * Constructor that receibes the target to reach, the list of jugs and a 
	 * limit of ticks.
	 * @param target The amount that a jug should achieve to declare the stage solved
	 * @param jugs  A array of Jugs
	 * @param maxTicks The limit of attempts of find out all posible states.
	 */
<span class="fc" id="L142">	public Stage(Integer target, Jug[] jugs, Integer maxTicks) {</span>
<span class="fc" id="L143">		this.target = target;</span>
<span class="fc" id="L144">		this.jugs = jugs;</span>
<span class="fc" id="L145">		ensureTargetAndJugCapacities();</span>
<span class="fc" id="L146">		this.maxTicks = new Ticks(maxTicks);</span>
<span class="fc" id="L147">	}</span>
	
	/**
	 * Check that there ara one or more jug in jugs, that has enough capcity
	 * for the target
	 */
	private void ensureTargetAndJugCapacities() {
<span class="fc bfc" id="L154" title="All 2 branches covered.">		if(!(target &gt; 0)) {</span>
<span class="fc" id="L155">			throw new IllegalArgumentException(&quot;Target (&quot;+target+&quot;) must be greater than 0&quot;);</span>
		}
<span class="fc bfc" id="L157" title="All 2 branches covered.">		for(Jug jug : jugs) {</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">			if(jug.getCapacity() &gt;= target) {</span>
				// return back when find one jug
<span class="fc" id="L160">				return;</span>
			}
		}
		// if no jug with enough capacity if found, throw a exception
<span class="fc" id="L164">		throw new IllegalArgumentException(&quot;Target (&quot;+target+&quot;) is too much bigger for the capacity of the jugs&quot;);</span>
	}
	
	/**
	 * Set the state with the amounts
	 * @param amounts 
	 */
	private void setState(Integer[] amounts) {
<span class="fc bfc" id="L172" title="All 2 branches covered.">		for(int a=0; a&lt;amounts.length; a++) {</span>
<span class="fc" id="L173">			jugs[a] = new Jug(jugs[a].getCapacity(), amounts[a]);</span>
		}
<span class="fc" id="L175">	}</span>
	
	/**
	 * Set the state with the amouns in comma-separted string format
	 * @param amounts 
	 */
	private void setState(String amounts) {
<span class="fc" id="L182">		String[] separated = amounts.split(&quot;,&quot;);</span>
<span class="fc" id="L183">		Integer[] numbers = new Integer[ separated.length ];</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">		for(int n=0; n&lt;separated.length; n++) {</span>
<span class="fc" id="L185">			numbers[n] = new Integer(separated[n]);</span>
		}
<span class="fc" id="L187">		setState(numbers);</span>
<span class="fc" id="L188">	}</span>
	
	/**
	 * Transform the actual state (the amount of each jug in order of declaration)
	 * into the comma-separated format of the amounts 
	 * @return 
	 */
	private String actualState() {
<span class="fc" id="L196">		String state = &quot;&quot;;</span>
<span class="fc bfc" id="L197" title="All 2 branches covered.">		for(int j=0; j&lt;jugs.length; j++) {</span>
<span class="fc" id="L198">			state += jugs[j].getAmount();</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">			if((j+1) &lt; jugs.length) {</span>
<span class="fc" id="L200">				state += &quot;,&quot;;</span>
			}
		}
<span class="fc" id="L203">		return state;</span>
	}
	
	/**
	 * Add the new state to the states used to find a solution. The state has to
	 * be a new state or finded with a better recursion level
	 * @param newState
	 * @param transition
	 * @param from
	 * @return 
	 */
	private Boolean addNewState(String newState, String transition, String from) {
<span class="fc bfc" id="L215" title="All 2 branches covered.">		if(states.containsKey(newState)) {</span>
			// if newState exists but was included in other recursion branch more deeper, overwrite and continue
			// In other words, the actual recursion level is lower than the state saved previously
<span class="fc" id="L218">			State state = states.get(newState);</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">			if(recursionLevel &lt; state.recursionLevel ) {</span>
<span class="fc" id="L220">				states.put(newState, new State(newState, transition, from, recursionLevel));</span>
			}
			else {
<span class="fc" id="L223">				return false;</span>
			}
<span class="fc" id="L225">		}</span>
		else {
<span class="fc" id="L227">			states.put(newState, new State(newState, transition, from, recursionLevel ));</span>
		}
		// at this point new state was stablished. Check if it is a valid solution
<span class="fc bfc" id="L230" title="All 2 branches covered.">		if(checkIsASolution()) {</span>
<span class="fc" id="L231">			print(&quot;SOLUTION!&quot;);</span>
			// if the new state is a solution mark it as a solution if it is the first
			// found or if it has a lower recursion level
<span class="pc bpc" id="L234" title="1 of 4 branches missed.">			if(bestStateSolution==null || recursionLevel &lt; states.get(bestStateSolution).recursionLevel) {</span>
<span class="fc" id="L235">				bestStateSolution = actualState();</span>
			}
		}
<span class="fc" id="L238">		return true;</span>
	}
	
	/**
	 * Check if the actual state is a valid solution (one of the jugs has 
	 * the targeted amount) and store it as the best solution. It's the best, because
	 * it is granted during addNewState method, becouse only replace states if 
	 * the newer one has less recursion than the older.
	 * @return Boolean
	 */
	private Boolean checkIsASolution() {
<span class="fc bfc" id="L249" title="All 2 branches covered.">		for(Jug jug : jugs) {</span>
<span class="fc bfc" id="L250" title="All 2 branches covered.">			if(jug.getAmount() == target) {</span>
<span class="fc" id="L251">				return true;</span>
			}
		}
<span class="fc" id="L254">		return false;</span>
	}
	
	/**
	 * Run the operation and after that, save the new state if necessary. In this
	 * case, explore a new bunch of instructions, calling recursively to findSolution()
	 * 
	 * @param type The operation's type: FILL, EMPTY or DUMP
	 * @param j1 The main jug that runs the operation
	 * @param j2 For the DUMP operation, the other jug, where to dump into.
	 * @throws MaxTicksReachException 
	 */
	private void operate(int type, Integer j1, Integer j2) throws MaxTicksReachException {
<span class="fc" id="L267">		maxTicks.tick();</span>
<span class="fc" id="L268">		String initialState = actualState();</span>
<span class="fc" id="L269">		String operation = &quot;&quot;;</span>
		
<span class="pc bpc" id="L271" title="1 of 4 branches missed.">		switch(type) {</span>
			case FILL:
<span class="fc" id="L273">				jugs[j1].fill();</span>
<span class="fc" id="L274">				operation = &quot;Fill &quot;+j1;</span>
<span class="fc" id="L275">				break;</span>
			case EMPTY:
<span class="fc" id="L277">				jugs[j1].empty();</span>
<span class="fc" id="L278">				operation = &quot;Empty &quot;+j1;</span>
<span class="fc" id="L279">				break;</span>
			case DUMP:
<span class="fc" id="L281">				jugs[j1].dumpInto(jugs[j2]);</span>
<span class="fc" id="L282">				operation = &quot;Dump &quot;+j1+&quot; into &quot;+j2;</span>
				break;
		}
		
<span class="fc" id="L286">		print(&quot;Exploring &quot;+initialState+&quot; / &quot;+operation+&quot; / &quot;+actualState());</span>
		
<span class="fc bfc" id="L288" title="All 2 branches covered.">		if(addNewState(actualState(), operation, initialState)) {</span>
<span class="fc" id="L289">			findSolution();	</span>
		}
		
<span class="fc" id="L292">		setState(initialState);</span>
<span class="fc" id="L293">	}</span>
	
	/**
	 * Show the states table for debugging.
	 * @return 
	 */
	private String showStates() {
<span class="fc" id="L300">		String out = &quot;&quot;;</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">		for(String stateName : states.keySet()) {</span>
<span class="fc" id="L302">			State state = states.get(stateName);</span>
<span class="fc" id="L303">			out += &quot;\t&quot;+state.name+&quot; [ &quot;+state.fromState+&quot; &quot;+state.operation+&quot; &quot;+state.recursionLevel+&quot; ]\n&quot;;</span>
<span class="fc" id="L304">		}</span>
<span class="fc" id="L305">		return out;</span>
	}
	
	/**
	 * Controls the recursion process. Run all operations with the current state.
	 * @throws MaxTicksReachException 
	 */
	private void findSolution() throws MaxTicksReachException {
<span class="fc" id="L313">		recursionLevel++;</span>
<span class="fc bfc" id="L314" title="All 2 branches covered.">		for(int j1=0; j1&lt;jugs.length; j1++) {</span>
<span class="fc bfc" id="L315" title="All 2 branches covered.">			for(int j2=0; j2&lt;jugs.length; j2++) {</span>
<span class="fc bfc" id="L316" title="All 2 branches covered.">				if(j1 != j2) {</span>
<span class="fc" id="L317">					operate(DUMP,j1,j2);</span>
				}
			}
<span class="fc" id="L320">			operate(FILL,j1,null);</span>
<span class="fc" id="L321">			operate(EMPTY,j1,null);</span>
		}
<span class="fc" id="L323">		recursionLevel--;</span>
<span class="fc" id="L324">	}</span>
	
	/**
	 * Build the rest of the solution found to be showed in CLI. The process 
	 * is recursive, building the operations needed from the indicated state 
	 * until initial.
	 * @param fromState 
	 * @return 
	 */
	private String buildSolution(String fromState) {
<span class="fc" id="L334">		String solution = &quot;&quot;;</span>
<span class="fc" id="L335">		State state = states.get(fromState);</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">		if(state.fromState != &quot;&quot;) {	// if not initial state (from != &quot;&quot;)</span>
<span class="fc" id="L337">			solution = buildSolution(state.fromState);</span>
		}
<span class="fc" id="L339">		return solution + &quot;\n&quot; + state.operation+&quot; (&quot;+fromState+&quot;)&quot;;</span>
	}
	
	/**
	 * Build the solution found to be showed in CLI.
	 * @param fromState 
	 * @return 
	 */
	private String buildSolution() {
<span class="fc" id="L348">		return buildSolution(bestStateSolution);</span>
	}
	
	/**
	 * Util method to print debug formated information to output.
	 * @param msg 
	 */
	private void print(String msg) {
<span class="fc bfc" id="L356" title="All 2 branches covered.">		if(debug) {</span>
<span class="fc" id="L357">			String pre = String.join(&quot;&quot;, Collections.nCopies(recursionLevel, &quot;  &quot;));</span>
<span class="fc" id="L358">			System.out.println(pre+msg);</span>
		}
<span class="fc" id="L360">	}</span>
	
	/**
	 * Init the process to create a list of instructions (fill x, empty x, 
	 * fill x into y) to achieve at least one jug with exactly target quantity 
	 * as its amount.
	 * @return String with the solution statements, if the solution could be 
	 * found within the number of attempts.
	 */
	public String solve() {
<span class="fc" id="L370">		String solution = &quot;&quot;;</span>
<span class="fc" id="L371">		states.clear();</span>
<span class="fc" id="L372">		recursionLevel = 0;</span>
		try {
			// init states with the actual state
<span class="fc" id="L375">			addNewState(actualState(), &quot;Start&quot;, &quot;&quot;);</span>
<span class="fc" id="L376">			findSolution();</span>
		}
<span class="fc" id="L378">		catch(MaxTicksReachException e) {</span>
<span class="fc" id="L379">			solution = &quot;Not all posibilities explored, too much intents.\n\n&quot;;</span>
<span class="fc" id="L380">		}</span>
<span class="fc bfc" id="L381" title="All 2 branches covered.">		if(bestStateSolution!=null) {</span>
<span class="fc" id="L382">			solution += &quot;Solution found:&quot; + buildSolution();</span>
		}
		else {
<span class="fc" id="L385">			solution += &quot;Solution not found&quot;;</span>
		}
<span class="fc" id="L387">		print(&quot;Full states table:\n&quot;+showStates());</span>
<span class="fc" id="L388">		return solution;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>